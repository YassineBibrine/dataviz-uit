Expert Analysis and Architectural Design for a Native C++ Data Structure and Algorithm Visualization Application




I. Executive Summary: Strategic Mandate and Technical Vision




1.1. Project Opportunity: Bridging the Gap in C++ Data Structure Learning Tools


The visualization of Data Structures and Algorithms (DSA) is a proven pedagogical method, offering students and developers the ability to observe abstract computational processes in action. Existing market solutions, such as VisuAlgo 1 and Algorithm Visualizer 2, are predominantly web-based platforms. These tools provide significant utility for structured learning, offering interactive simulations for dozens of algorithms, sometimes including C++ support.3
However, these web-based environments inherently face limitations regarding computational performance and deep system access, constraints that become particularly acute when visualizing C++ code. C++ relies heavily on manual memory management, pointer arithmetic, and complex object layouts—concepts that web applications struggle to display accurately without significant overhead. A critical gap exists for a high-performance, native desktop application that can not only visualize high-level algorithmic logic but also provide high-fidelity visualization of the underlying C++ memory state, including pointers, uninitialized memory, and nested structures, a capability demonstrated as essential by tools focusing on C/C++ runtime tracing.4
The strategic vision for this project is to develop an expert-level tool that leverages the native efficiency of C++ 5 to offer superior performance and a nuanced understanding of low-level memory operations. This approach addresses the limitations of oversimplified visualizations that may lead to misconceptions 6, providing an accurate, scalable, and powerful platform for C++ education and analysis.


1.2. Architectural Summary: The Three-Engine Model


To achieve the highly complex functional requirements—specifically the two-way transformation of code-to-visualization (C2V) and visualization-to-code (V2C)—the proposed system must adopt a highly modular and specialized architecture known as the Three-Engine Model. This model ensures functional separation, allowing each core competency to rely on the most effective C++ tools available.
1. Frontend Engine (GUI/Rendering): Responsible for user interaction, code display, and rendering the dynamic visualizations. This engine requires a robust, cross-platform framework such as the Qt Framework.5
2. Analysis Engine (C2V): Handles the rigorous task of C++ source code parsing, structure extraction, and runtime execution tracing. This engine must be powered by the industry-standard compiler infrastructure, specifically the Clang/LLVM toolchain, enabling deep Abstract Syntax Tree (AST) access and compilation instrumentation.8
3. Synthesis Engine (V2C): Manages the inverse operation: translating user manipulations of the graphical data structure back into syntactically correct and idiomatically appropriate C++ source code snippets. This leverages Clang's code rewriting capabilities.8


1.3. Key Technology Recommendations


The success of this complex two-way transformation model is predicated on the selection of robust, performance-optimized C++ libraries. The following technologies are recommended for the core implementation:


Component
	Primary Library/Framework
	Rationale
	Integration Method
	GUI/Desktop Framework
	Qt (QWidgets/QML)
	Leading cross-platform solution, robust native UI capabilities, signal/slot architecture suitable for state transmission.5
	Native C++ integration
	Code Analysis Engine
	LLVM/Clang LibTooling
	Provides necessary access to C++ AST for structure identification (C2V) and code rewriting (V2C).8
	Custom standalone tool integration
	Data Structure Logic/Serialization
	Boost Graph Library
	High-quality implementation of complex structures and essential utility for serializing graph structures to DOT format.[5, 10]
	Direct C++ linkage
	Graph Layout Generation
	Graphviz
	Industry-standard for algorithmic graph layout, providing high-quality, readable abstract diagrams.[11, 12]
	Runtime execution of dot executable, reading back layout data
	

II. Market and Competitive Landscape Analysis




2.1. Categorization of Algorithm Visualization Software (AVS)


Algorithm Visualization Software (AVS) can be broadly categorized into three types: pre-scripted simulations (like VisuAlgo), custom code interpreters (like Algorithm Visualizer), and integrated debugger visualizers (like Natvis).
The Natvis framework, relevant specifically to the C++ domain, customizes how native types are displayed in debugger windows, such as the Locals and Watch windows within Visual Studio.13 It allows developers to define XML rules (in .natvis files) to visualize complex class hierarchies more simply, revealing underlying values of custom types like strings or complex structures.13 While Natvis is an exemplary solution for visualizing custom C++ types during debugging, it is fundamentally restricted to customizing the debugger's output. It cannot serve as the core basis for a standalone desktop application, nor does it provide the necessary engine for the C2V execution mapping required for algorithm visualization. This highlights the architectural necessity of building a specialized, non-IDE-dependent tool.


2.2. Detailed Comparative Review of Existing AVS Solutions


The competitive landscape is dominated by tools offering visualization for a wide array of algorithms and data structures.14
* VisuAlgo: This tool, originating from the National University of Singapore (NUS) 1, is highly effective for structured, guided learning. It supports visualizations for over 40 algorithms and data structures and includes performance analysis features.3 Its primary limitation for the proposed project is the absence of custom code input, meaning users cannot test or visualize their own C++ implementations directly against the guided lessons.3
* Algorithm Visualizer: This platform addresses the custom code gap, allowing users to input and visualize code written in several languages, including C++, JavaScript, and Python.3 It offers real-time animation control and covers over 50 algorithms.3 However, as a web-based solution, it is susceptible to limitations regarding performance representation and may oversimplify complex algorithms or fail to represent performance accurately when scaled to larger datasets.6
* Python Tutor (C/C++ Mode): This tool provides a critical reference point for the C/C++ visualization market. It utilizes Valgrind, a memory-safe run-time traversal engine, to accurately display critical C++ concepts such as pointers, uninitialized memory, out-of-bounds errors, nested structures, and type punning.4 This dynamic analysis of memory addresses and pointer flow is precisely what differentiates a high-fidelity C++ visualization tool from a generic algorithm visualizer, confirming the need for deep runtime tracing.


2.3. Identifying Critical Market Deficiencies and The Desktop Advantage


The analysis of existing AVS tools reveals two major deficiencies in the current market, particularly concerning expert-level C++ visualization.
First, the complexity of C++ memory management, often referred to as the 'C++ Memory Dilemma,' mandates a shift in visualization focus from abstract high-level steps to dynamic, low-level memory representation. Linked structures, such as linked lists and graphs implemented with custom pointers, are fundamental to C++. Static analysis merely identifies the structure's definition.15 To be truly useful, the application must integrate a mechanism (similar to Python Tutor's Valgrind integration 4) to accurately track heap allocations and pointer assignments in real-time. This necessitates the creation of a specialized, compiler-integrated analysis suite capable of capturing precise memory states.
Second, the market suffers from limitations in high-fidelity performance and scalability. Current visualizations are often criticized for oversimplifying algorithms or failing to accurately represent true performance characteristics when scaled.6 A native C++ desktop application offers a distinct architectural advantage, providing significantly higher performance and reduced overhead compared to web-native applications, which often rely on intermediary technologies like Node.js.16 Leveraging C++'s efficiency 5 allows the application to handle larger data sets and simulate high-frequency operations (like complex sorting or large graph traversal) with accuracy that reflects real-world performance, successfully occupying the market gap for expert users.
Table 1: Competitive Analysis of Data Structure and Algorithm Visualizers


Tool
	Primary Platform
	C++ Code Input
	Core Visualization Method
	Key Limitation for Proposed App
	VisuAlgo
	Web/Browser
	No Custom Code
	Pre-scripted/Guided Simulation
	Lacks custom code execution and development integration [1, 3]
	Algorithm Visualizer
	Web/Browser
	Yes (C++/JS/Python)
	Custom Code Interpretation
	Performance constraints, limited handling of low-level C++ memory [3, 6]
	Python Tutor
	Web/Browser
	Yes (C/C++)
	Runtime Memory Tracing (Valgrind)
	Focuses on debugging, not a platform for desktop application building or V2C synthesis 4
	Proposed Desktop App
	Native C++ Desktop
	Full (AST/Runtime)
	Compiler-Integrated State Mapping
	High complexity and development cost of integrating Clang/LLVM
	

III. Application Functional Requirements and Visualization Core




3.1. General Interface and Desktop Requirements


The application must be designed as a robust, cross-platform desktop tool, necessitating a powerful framework like Qt.5 The graphical user interface (GUI) should integrate several key panels: an interactive code editor supporting syntax highlighting 17, a large visualization pane for the dynamic diagrams, a control panel for algorithm execution (play, pause, step-forward, step-backward), and a diagnostic output window for logging performance metrics and error messages.


3.2. Core Data Structure Visualization Modules


The visualization engine must support the primary categories of data structures critical to computer science education and development:
* Graphs: Support is mandatory for both explicit structure representation (e.g., adjacency lists or matrices) and abstract node-link diagrams.11 The system must visualize undirected, directed, weighted, and multi-graphs, enabling the tracing of critical path-finding and connectivity algorithms.
* Trees and Advanced Structures: Beyond basic binary trees, the tool must visualize complex balancing mechanisms essential for efficient searching and retrieval. This includes Binary Search Trees (BST), AVL Trees, Red-Black Trees, Splay Trees, B-Trees, and B+ Trees.14
* Linear Structures: Visualization must cover arrays, stacks, queues, and most importantly, singly and doubly chained lists (linked lists).14 For C++ implementations, the visualization must explicitly show how raw pointers or smart pointers connect nodes, visualizing the memory addresses involved, which is crucial for understanding data structure integrity.
* Hashing: The system should demonstrate how collisions are handled in various hashing schemes, including Open Hash Tables (Closed Addressing) and Closed Hash Tables (Open Addressing/Buckets).14


3.3. Algorithmic Visualization Granularity and Control


The system must support visualization for classic algorithms, including sorting routines (e.g., Merge Sort, Quick Sort) and complex graph algorithms such as Dijkstra’s shortest path, Breadth-First Search (BFS), Depth-First Search (DFS), and Minimum Spanning Tree (MST) approaches.14


Granularity and Layout


To manage the visual complexity of dynamically changing structures, the visualization pipeline must employ a strategy of decoupled layout management. Drawing complex, balanced structures like Red-Black Trees or optimal graph layouts algorithmically is a field of study unto itself. Relying on an existing, specialized engine drastically reduces project risk. Graphviz is the leading open-source software for generating abstract graph diagrams.11 By leveraging the Boost Graph Library (BGL), the application can serialize the C++ runtime structure into the Graphviz-native DOT language.10 The engine then executes Graphviz to calculate the optimal node positioning, and the Frontend Engine renders the resulting coordinates. This architecture ensures aesthetically pleasing and algorithmically correct visual layouts without requiring custom implementation of complex layout algorithms.
Furthermore, to effectively address the limitations of existing tools (oversimplification 6), the application must support variable visualization granularity. While basic visualizations (e.g., nodes changing color to signify state) are useful for understanding high-level logic, expert C++ developers require a deeper view. The system must allow users to switch to a low-level memory view, demonstrating the direct manipulation of pointer values and memory addresses during critical operations like node insertion or deletion. This detailed visibility, mirroring successful memory tracing techniques 4, is the key differentiator for an advanced C++ visualization tool.


State Capture and Performance Metrics


The application must capture execution states at a fine granularity, typically before and after a key operation that alters the data structure or algorithm state (e.g., edge relaxation in Dijkstra, or a pivot selection in Quick Sort). Full animation control, including playback, pausing, and stepping (forward/limited backward), must be implemented.3 Crucially, the tool must go beyond simple animation by providing dynamic performance simulation. This includes displaying metrics such as the number of comparisons, memory swaps, and total elapsed time. By allowing users to visualize runtime complexity on different data sizes, the system accurately represents true algorithmic performance characteristics, successfully overcoming a noted limitation in existing educational visualization platforms.6


IV. The C++ Code Analysis (C2V) Engine Architecture




4.1. The Technical Challenge: C++ Static and Dynamic Analysis


C++ presents unique challenges for automated code analysis compared to languages with built-in reflection or runtime virtual machines. Its complex grammar, reliance on the preprocessor, deep template metaprogramming, and manual memory management mean that developing a robust, proprietary parser is prohibitively difficult and resource-intensive.18 Therefore, the analysis of user-provided C++ code must be handled by leveraging established compiler infrastructure.
Visualization requires two levels of analysis:
1. Static Analysis: Identifying the definition of data structures (e.g., class structures, member variables, and function signatures).15
2. Dynamic Analysis: Capturing the run-time values of variables, heap allocations, and pointer targets during execution.


4.2. Architectural Recommendation: The Clang/LLVM Frontend


The most scalable and technically robust solution for deep C++ analysis is the use of the LLVM compiler infrastructure, specifically its frontend, Clang, integrated via LibTooling.8 Clang provides full access to the Abstract Syntax Tree (AST), which is the structured representation of the C++ source code.
* LibTooling Integration: LibTooling is designed explicitly for building standalone analysis tools, enabling seamless integration into the desktop application.8
* Structure Identification: Within the analysis engine, LibASTMatchers allows for high-level, declarative searching across the AST.9 This is utilized to efficiently identify user-defined DSA implementations—for example, searching for classes containing self-referential pointers that denote a linked list node, or identifying member functions used for traversal or manipulation.
* Toolchain Independence: Although the analysis engine relies on Clang/LLVM, it maintains independence from the user's preferred development environment (e.g., Visual Studio 19 or VS Code with GCC/Clang 20). Clang's Compilation Database functionality allows the tool to parse complex source files, accounting for necessary compilation flags and include paths, ensuring accurate AST generation regardless of the user's native setup.8


4.3. Strategy for Runtime Data Extraction and State Mapping (Dynamic Analysis)


For algorithm visualization, capturing the dynamic state of key variables (like a priority queue in Dijkstra's algorithm or an array during sorting) is essential. Static analysis tools, such as Cppcheck, are designed primarily for finding bugs (e.g., detecting undefined behavior, dead pointers, or memory leaks) 21 but cannot determine the progression of state necessary for visualization.
To overcome this, the architecture requires compiler-level integration for dynamic analysis:
1. Instrumentation: The user's uploaded C++ code must be instrumented. This technique, analogous to how memory sanitizers like ASAN and UBSAN 22 insert runtime checks, involves using LLVM passes to automatically inject specialized visualization callbacks (or "Event Loggers") into the compiled code.
2. State Logging: These injected callbacks are placed strategically before and after operations that modify the data structure's state (e.g., pointer assignments, array index updates). When the instrumented code is executed, it generates a precise log detailing variable values, memory addresses, and the specific line numbers where the changes occurred.
3. Visualization Model Mapping: The Visualization Engine reads this execution log, efficiently mapping the captured runtime states onto the graphical elements (nodes, edges, pointers) in the UI, enabling step-by-step playback.
The necessity of compiler-level instrumentation elevates the project from a simple visualization tool to a specialized, state-logging debugger, confirming that dynamic hooking is mandatory to accurately represent the runtime characteristics of C++.
Table 2: C++ Code Analysis Libraries Comparison (Focusing on C2V Capabilities)


Library/Tool
	Core Function
	Data Structure Extraction
	Runtime State Capture
	C++ Code Rewriting (V2C)
	LLVM/Clang LibTooling
	Compiler Frontend/AST Access
	High (Via LibASTMatchers) [9, 15]
	Medium (Requires custom instrumentation passes)
	High (Tooling/Rewriter) 8
	CppCheck
	Static Analysis (Bugs)
	Low (Focus on data flow and UB) 21
	None (Static only)
	None (Diagnostic focus)
	Natvis
	Debugger Visualization Format
	N/A (Visualization definition)
	High (Integrated into VS Debugger)
	None
	DMS Software Toolkit
	Program Transformation
	High (Industrial Scale) 23
	N/A (Static focus)
	High (Pattern-directed transformation) [24]
	

V. The Inverse Functionality: Visualization-to-Code (V2C) Synthesis




5.1. Defining the Inverse Process (V2C)


The Visualization-to-Code (V2C) feature is a core requirement that closes the learning loop, translating user input from the graphical domain (e.g., visually adding a node or changing an edge weight) into syntactically correct C++ source code.25 This function ensures that the visual representation precisely maps back to executable code, serving a critical pedagogical role by linking abstract structures to concrete implementation details and providing the developer with precise source code location feedback.26


5.2. V2C Implementation: AST Manipulation and Source Code Generation


The Synthesis Engine performs V2C by leveraging the same robust compiler infrastructure used for C2V.
1. AST Synthesis: When a user interacts with the graphical data structure, the Synthesis Engine determines the equivalent C++ manipulation (e.g., a function call like g.add_node("X")). It then dynamically synthesizes the corresponding Abstract Syntax Tree nodes required for that statement.
2. Clang Rewriter Integration: Clang’s LibTooling provides specific APIs for program transformation, known as the Clang Rewriter.8 The engine uses the Rewriter to insert the newly synthesized AST fragment into the user’s existing source file, typically at a predefined insertion point.
3. Code Fidelity and Mapping: For this process to be effective, the generated code must adhere strictly to the Application Programming Interface (API) defined by the user’s custom data structure (which was identified during the C2V analysis phase). If the user implemented an adjacency list graph with a specific method signature (e.g., graph.insertEdge(u, v)), the V2C generation must use that exact signature, rather than a generic one. This high level of source code mapping fidelity ensures the generated code is immediately usable and contextually correct.
4. Pretty-Printing and Source Code Quality: Simple insertion of code can result in poorly formatted output. Industrial tools designed for large-scale source code modification, such as the DMS Software Reengineering Toolkit, demonstrate the necessity of automatic pretty-printer generation to ensure the output AST converts back into nicely formatted, legal source code, preserving comments and required layouts.23 The Synthesis Engine must incorporate formatting standards, aligning with the philosophy of tools like clang-format 27, to maintain professional code quality.


5.3. Case Study: Dynamic Code Generation


Consider a user who is visually manipulating a graph data structure displayed in the visualization pane.
* User Action: The user drags a new edge between Node A and Node C and assigns it a weight of 5.
* Synthesis Pipeline:
   1. The GUI captures the high-level action (Add Edge: A $\rightarrow$ C, Weight: 5).
   2. The Synthesis Engine consults the C2V engine's catalog to identify the user's specific graph manipulation function (e.g., g.set_weight(...)).
   3. It generates the string representation: g.set_weight("A", "C", 5);.
   4. The Clang Rewriter inserts this syntactically correct line into the source file displayed in the code editor.
   5. The visual display and the code editor update instantaneously, linking the visual action directly to the implementation code.
This immediate, bidirectional feedback loop is crucial for reinforcing the implementation details necessary for mastery of C++ data structures.


VI. Proposed C++ Technology Stack for Implementation




6.1. Desktop GUI Framework Selection


The selection of the GUI framework is critical for delivering a high-performance, cross-platform desktop application.
The primary recommendation is the Qt Framework.7 Qt is widely used in professional C++ development for creating graphical user interfaces.5 It provides comprehensive libraries (QWidgets for classic UI, QML for modern/declarative UI) that support Windows, macOS, and Linux.7 Qt’s powerful signal and slot mechanism is ideally suited for communicating complex state changes captured by the Analysis Engine to the Visualization Engine efficiently, which is a major benefit over lower-level libraries. This recommendation is validated by other successful open-source projects, such as QVGE (a graph editor), which successfully integrate Qt 5.x with Graphviz for visualization.12
An alternative, higher-performance consideration is an Immediate Mode GUI (ImGui), often paired with rendering layers like SDL.5 ImGui can eliminate the abstraction layer of "adapter classes" found in reactive frameworks like Qt, potentially offering slightly better performance for complex, highly dynamic rendering.28 However, Qt provides a more complete set of features necessary for a full-featured desktop application, including advanced window management, file I/O, and networking, which generally favors Qt for a project of this functional breadth.


6.2. Graphics Rendering and Layout Engine


The visualization component requires robust tools for both layout generation and actual rendering.


Graph Layout: Graphviz and Boost


The reliance on Graphviz for layout is non-negotiable.11 The application should use the Boost Graph Library (BGL) for internal representation of abstract structures like graphs and trees.5 BGL contains functionality to serialize the graph object directly into the DOT language.10 The engine then uses Graphviz to determine the optimized spatial coordinates of all nodes and edges. This approach utilizes a dedicated, proven layout algorithm, ensuring the visual clarity of structures like AVL or Red-Black trees.


Custom Rendering


Once layout coordinates are determined by Graphviz, the Frontend Engine must render the final output. While standard Qt drawing functions may suffice, if high-performance 3D visualization or complex shading is required (e.g., visualizing dense graph metrics using heatmaps 17), dedicated graphics middleware like Magnum (a lightweight, modular graphics library designed for data visualization 30) or bgfx (a cross-platform, graphics API agnostic library 30) may be used. For initial development, focusing on robust 2D rendering through Qt is the lowest-risk approach.


6.3. Essential C++ Libraries


The foundation of the entire system is built upon modern C++ standards, requiring compiler support for C++11 and later.12
1. Boost: Beyond BGL, the Boost collection provides essential utilities for threading, filesystem access, and other foundational components required for a complex application.5
2. Clang/LLVM Tooling: As detailed in Section IV, LibTooling is paramount for all parsing and rewriting functionality.8
3. Serialization: A fast serialization library (such as RapidJSON) is required to parse the execution logs generated by the instrumented C++ code, allowing the Visualization Engine to quickly ingest and process the state changes captured during runtime.


VII. Conclusion and Implementation Roadmap




7.1. Nuanced Conclusions and Strategic Recommendations


The creation of a native C++ desktop application for DSA visualization, complete with two-way Code-to-Visualization (C2V) and Visualization-to-Code (V2C) capabilities, is technically feasible. The complexity of the project, however, is significantly higher than that of typical educational web platforms.
The primary competitive advantage lies in the application's native C++ execution, which guarantees superior performance and the capacity for high-fidelity visualization of memory and pointers, addressing critical shortcomings identified in existing web-based tools.4
The most critical architectural decision is the deep integration of the LLVM/Clang toolchain. Clang LibTooling is the only robust, open-source C++ technology capable of handling the necessary static structure identification (via AST matching) and the dynamic code synthesis and rewriting required for V2C.8 Successfully implementing C2V requires specialized expertise in creating compiler instrumentation passes to capture runtime state accurately, a process that moves the application into the realm of custom compiler development.
Strategic funding and development resources must therefore be heavily prioritized toward acquiring expertise in the LLVM/Clang ecosystem, as this represents both the highest technical risk and the greatest potential for market differentiation.


7.2. Phased Implementation Roadmap


A phased approach is recommended to manage risk and deliver core functionality incrementally:


Phase
	Focus Area
	Key Deliverables
	Technical Risk Assessment
	1: Foundation
	GUI, Layout, and Static Rendering
	Cross-platform GUI (Qt), Code Editor, Graphviz/Boost Graph Library integration for layout, Visualization of pre-defined structures (graphs, trees) from manual data input.
	Low. Utilizes proven, low-risk technology (Qt 7, Graphviz 12).
	2: Code-to-Visualization (C2V) Engine
	Static and Dynamic Analysis
	Clang LibTooling integration (AST parsing), LibASTMatchers for structure identification, Initial implementation of compiler instrumentation (LLVM pass) for state logging of simple structures (arrays, linked lists), Runtime state mapping.
	High. Requires specialized LLVM/Compiler expertise for instrumentation.
	3: Inverse Synthesis (V2C) and Advanced Features
	Full Bidirectional Flow
	Clang Rewriter implementation for V2C, Integration of pretty-printing, Implementation of visualization controls for all advanced structures (Red-Black, B-Trees 14), Granularity control (abstract vs. memory view).
	High. Requires complex API mapping and robust Rewriter implementation.8
	Sources des citations
1. VisuAlgo: visualising data structures and algorithms through animation, consulté le octobre 30, 2025, https://visualgo.net/
2. Algorithm Visualizer, consulté le octobre 30, 2025, https://algorithm-visualizer.org/
3. Algorithm Visualizer vs. VisuAlgo: Comparison - Daily.dev, consulté le octobre 30, 2025, https://daily.dev/blog/algorithm-visualizer-vs-visualgo-comparison
4. Python Tutor code visualizer: Visualize code in Python, JavaScript ..., consulté le octobre 30, 2025, https://pythontutor.com/visualize.html
5. Top 10 C++ Libraries and Frameworks in 2024 - AmorServ, consulté le octobre 30, 2025, https://amorserv.com/insights/top-10-c-libraries-and-frameworks-in-2024
6. Exploring Algorithm Visualization Tools: Enhancing Understanding and Learning, consulté le octobre 30, 2025, https://algocademy.com/blog/exploring-algorithm-visualization-tools-enhancing-understanding-and-learning/
7. Development Framework for Cross-platform Applications - Qt, consulté le octobre 30, 2025, https://www.qt.io/product/framework
8. LibTooling — Clang 22.0.0git documentation, consulté le octobre 30, 2025, https://clang.llvm.org/docs/LibTooling.html
9. Tutorial for building tools using LibTooling and LibASTMatchers - Clang - LLVM, consulté le octobre 30, 2025, https://clang.llvm.org/docs/LibASTMatchersTutorial.html
10. Graph visualization (boost graph) - c++ - Stack Overflow, consulté le octobre 30, 2025, https://stackoverflow.com/questions/7931164/graph-visualization-boost-graph
11. Graphviz, consulté le octobre 30, 2025, https://graphviz.org/
12. Qt Visual Graph Editor | qvge - GitHub Pages, consulté le octobre 30, 2025, https://arsmasiuk.github.io/qvge/
13. Create custom views of C++ objects - Visual Studio (Windows) - Microsoft Learn, consulté le octobre 30, 2025, https://learn.microsoft.com/en-us/visualstudio/debugger/create-custom-views-of-native-objects?view=vs-2022
14. Data Structure Visualization - Computer Science - University of San Francisco, consulté le octobre 30, 2025, https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
15. standardese/cppast: Library to parse and work with the C++ AST - GitHub, consulté le octobre 30, 2025, https://github.com/standardese/cppast
16. Lightning Talk: The Present and Future of Cross-Platform GUI in C++ - Matt Aber - CppCon 2024 - YouTube, consulté le octobre 30, 2025, https://www.youtube.com/watch?v=p9LeAqoshkQ
17. Code Visualization: 4 Types of Diagrams and 5 Useful Tools - CodeSee, consulté le octobre 30, 2025, https://www.codesee.io/learning-center/code-visualization
18. Generate an AST in C++ - Stack Overflow, consulté le octobre 30, 2025, https://stackoverflow.com/questions/28530284/generate-an-ast-in-c
19. Install C and C++ support in Visual Studio - Microsoft Learn, consulté le octobre 30, 2025, https://learn.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=msvc-170
20. C/C++ for Visual Studio Code, consulté le octobre 30, 2025, https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools
21. Cppcheck - A tool for static C/C++ code analysis, consulté le octobre 30, 2025, https://cppcheck.sourceforge.io/
22. C++ Code & Execution Analyzers | hacking C++, consulté le octobre 30, 2025, https://hackingcpp.com/cpp/tools/analyzers.html
23. DMS Software Reengineering Toolkit - Semantic Designs, consulté le octobre 30, 2025, https://www.semanticdesigns.com/Products/DMS/DMSToolkit.html?Home=PHPTools
24. Implementation of Graph in C++ - GeeksforGeeks, consulté le octobre 30, 2025, https://www.geeksforgeeks.org/cpp/implementation-of-graph-in-cpp/
25. Semantic Code Graph – an information model to facilitate software comprehension - arXiv, consulté le octobre 30, 2025, https://arxiv.org/html/2310.02128v2
26. Pretty printing C++ with Clang-Format - Successful Software, consulté le octobre 30, 2025, https://successfulsoftware.net/2016/05/09/pretty-printing-c-with-clang-format/
27. Why Qt and not IMGUI? : r/programming - Reddit, consulté le octobre 30, 2025, https://www.reddit.com/r/programming/comments/5zrqcn/why_qt_and_not_imgui/
28. Why Qt and not IMGUI? - Andreas on Coding, consulté le octobre 30, 2025, https://deplinenoise.wordpress.com/2017/03/05/why-qt-and-not-imgui/
29. jslee02/awesome-graphics-libraries: :sunglasses - GitHub, consulté le octobre 30, 2025, https://github.com/jslee02/awesome-graphics-libraries