# Code Generator & Parser Feature Guide

## ?? Overview

DataViz UIT now includes a powerful **bidirectional code translation** feature that allows you to:
1. **Generate C++ code** from visualized data structures
2. **Parse C++ code** to automatically create and visualize data structures

This feature bridges the gap between visual representation and actual code implementation.

---

## ?? Features

### 1. Code Generation (Structure ? C++)

Convert any visualized data structure into compilable C++ code:

- **Array**: Generates `std::vector<int>` with initialization
- **Linked List**: Generates node-based linked list with traversal
- **Binary Tree**: Generates BST with insert operations
- **Graph**: Generates adjacency list graph implementation

**Generated code includes:**
- Complete, compilable C++ code
- Helper functions (print, traverse, etc.)
- Memory management (where applicable)
- Optional explanatory comments

### 2. Code Parsing (C++ ? Structure)

Parse C++ code and automatically create structures:

- **Automatic type detection** from code patterns
- **Value extraction** from initializers and constructors
- **Edge detection** for graphs and trees
- **Error reporting** with helpful messages

---

## ?? How to Use

### Opening the Code Generator

**Method 1: Menu Bar**
```
Tools ? Code Generator & Parser...
```

**Method 2: Keyboard (if shortcut added)**
```
Ctrl+G (or configured shortcut)
```

---

## ?? Generate Code from Structure

### Step 1: Create or Select a Structure

First, you need a structure to generate code from:

**Option A: Generate from Control Panel**
1. Go to Control Panel
2. Select structure type (Array, Graph, Tree, List)
3. Set size and parameters
4. Structure is auto-created

**Option B: Draw Interactively**
1. Drag nodes from Toolbox to canvas
2. Connect with Link tool
3. Finalize in Structure Selector
4. Choose type and name

**Option C: Select Existing Structure**
1. Click on a structure in Structure Selector list

### Step 2: Open Code Generator

1. Click **Tools ? Code Generator & Parser**
2. You'll see a dialog with two tabs

### Step 3: Generate Tab

1. **Select Structure**: Choose from dropdown
   - Shows all available structures
   - Format: "Name [Type] ?/?"
   
2. **Options**:
   - ? **Include comments**: Adds explanatory comments to generated code
   
3. **Click "Generate C++ Code"**
   - Code appears in the text area below
   
4. **Copy to Clipboard**
   - Click "Copy to Clipboard" button
   - Paste into your IDE or text editor

### Example Generated Code

**Array Example:**
```cpp
// Auto-generated Array C++ Code
// Generated by DataViz UIT

#include <iostream>
#include <vector>

// Array Structure
int main() {
    // Initialize array
    std::vector<int> arr = {64, 34, 25, 12, 22, 11, 90};

    // Display array
    std::cout << "Array: ";
  for (int val : arr) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

**Linked List Example:**
```cpp
// Node structure for linked list
struct Node {
    int value;
    Node* next;
    Node(int val) : value(val), next(nullptr) {}
};

// Function to print the list
void printList(Node* head) {
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->value;
        if (current->next != nullptr) std::cout << " -> ";
        current = current->next;
    }
    std::cout << " -> nullptr" << std::endl;
}

int main() {
    // Create linked list
    Node* head = new Node(10);
    Node* current = head;

    current->next = new Node(20);
    current = current->next;
    current->next = new Node(30);
    current = current->next;

    // Display list
    std::cout << "Linked List: ";
    printList(head);

    // Clean up memory
while (head != nullptr) {
        Node* temp = head;
        head = head->next;
      delete temp;
    }

    return 0;
}
```

**Graph Example:**
```cpp
// Simple Graph implementation using adjacency list
class Graph {
private:
    std::map<std::string, std::vector<std::string>> adjList;
  bool directed;

public:
    Graph(bool isDirected = false) : directed(isDirected) {}

    void addNode(const std::string& node) {
if (adjList.find(node) == adjList.end()) {
            adjList[node] = std::vector<std::string>();
        }
    }

 void addEdge(const std::string& from, const std::string& to) {
     addNode(from);
        addNode(to);
        adjList[from].push_back(to);
        if (!directed) {
            adjList[to].push_back(from);
     }
    }

    void display() {
        for (const auto& pair : adjList) {
            std::cout << pair.first << " -> ";
        for (const auto& neighbor : pair.second) {
                std::cout << neighbor << " ";
            }
            std::cout << std::endl;
        }
}
};
```

---

## ?? Parse Code to Create Structure

### Step 1: Write or Paste C++ Code

Switch to the **"Parse Code to Create Structure"** tab:

1. **Input area**: Large text editor
2. **Paste or type** your C++ code
3. Code must follow supported patterns (see below)

### Step 2: Click "Parse & Create Structure"

The parser will:
1. ? Detect structure type automatically
2. ? Extract values and relationships
3. ? Create the structure in DataModelManager
4. ? Add to Structure Selector list
5. ? Visualize immediately

### Step 3: View Results

**Parse Result Box shows:**
- ? **Detected Type**: Array, List, Tree, or Graph
- **Values**: Extracted node values
- **Nodes**: Node IDs (for graphs/trees)
- **Edges**: Connections between nodes
- **Structure ID**: Created structure identifier

---

## ?? Supported Code Patterns

### Pattern 1: Array

```cpp
std::vector<int> arr = {1, 2, 3, 4, 5};
```

**What Parser Looks For:**
- `vector<int>` or `int arr[]`
- Initializer list: `{ values }`

### Pattern 2: Linked List

```cpp
Node* head = new Node(10);
current->next = new Node(20);
current->next = new Node(30);
```

**What Parser Looks For:**
- `new Node(value)` pattern
- `->next` connections

### Pattern 3: Binary Tree

```cpp
TreeNode* root = nullptr;
root = insert(root, 50);
root = insert(root, 30);
root = insert(root, 70);
```

**OR:**

```cpp
TreeNode* root = new TreeNode(50);
root->left = new TreeNode(30);
root->right = new TreeNode(70);
```

**What Parser Looks For:**
- `insert(root, value)` calls
- `new TreeNode(value)`
- `->left` and `->right`

### Pattern 4: Graph

```cpp
Graph g(false);  // undirected
g.addNode("A");
g.addNode("B");
g.addNode("C");
g.addEdge("A", "B");
g.addEdge("B", "C");
```

**What Parser Looks For:**
- `addNode("id")` calls
- `addEdge("from", "to")` calls
- `Graph(true)` for directed graphs

---

## ?? Complete Workflow Example

### Scenario: Create Graph from Code

**Step 1: Paste Code**
```cpp
Graph g(false);
g.addNode("A");
g.addNode("B");
g.addNode("C");
g.addEdge("A", "B");
g.addEdge("B", "C");
g.addEdge("C", "A");
```

**Step 2: Parse**
- Click "Parse & Create Structure"

**Step 3: Result**
```
? Parse Successful!

Detected Type: Graph

Nodes:
  A (value: 0)
  B (value: 1)
  C (value: 2)

Edges:
  A -> B
  B -> C
  C -> A

? Structure created successfully!
ID: custom_3
```

**Step 4: Automatic Actions**
- Structure appears in **Structure Selector**
- Name: "Parsed Graph [Graph] ?"
- Auto-selected for algorithms
- **Visualization updates** to show the graph
- **Toolbox updates** with Graph tools

**Step 5: Use the Structure**
- Select an algorithm (e.g., BFS, DFS)
- Click Play to visualize
- Or modify using interactive tools

---

## ?? Advanced Features

### Custom Structure Names

When parsing, the system auto-generates names:
- "Parsed Array"
- "Parsed List"
- "Parsed Tree"
- "Parsed Graph"

You can **rename** after creation:
1. Select structure in Structure Selector
2. Click "Rename" button
3. Enter new name

### Directed vs Undirected Graphs

**Directed:**
```cpp
Graph g(true);  // directed graph
```

**Undirected:**
```cpp
Graph g(false);  // undirected graph
```

Parser detects this automatically!

### Error Handling

If parsing fails, you'll see:

```
? Parse Failed

No array values found. Expected format: vector<int> arr = {1, 2, 3};
```

**Common Issues:**
- Missing semicolons
- Incorrect syntax
- Unsupported patterns
- Empty code

**Solutions:**
- Follow the pattern examples
- Check for typos
- Ensure complete statements

---

## ?? Use Cases

### 1. **Educational**
- Generate code from visual structures for learning
- Understand how structures are implemented
- Practice translating visuals to code

### 2. **Code Review**
- Visualize existing data structure code
- Debug complex structures visually
- Understand legacy code faster

### 3. **Prototyping**
- Quickly create structures from code snippets
- Test algorithm implementations
- Compare different structures

### 4. **Documentation**
- Export structures as code examples
- Share implementations with team
- Create tutorials with working code

### 5. **Testing**
- Parse test case inputs
- Generate test data structures
- Verify algorithm correctness

---

## ?? Troubleshooting

### Issue 1: "No structures available"

**Cause:** No structures created yet

**Solution:**
- Create at least one structure first
- Use Control Panel or draw interactively
- Or parse code to create one

### Issue 2: "Parse Failed - Unknown structure type"

**Cause:** Code doesn't match supported patterns

**Solution:**
- Check code follows pattern examples
- Ensure keywords are present:
  - Array: `vector<int>`
  - List: `Node`, `next`
  - Tree: `TreeNode`, `left`, `right`
  - Graph: `addNode`, `addEdge`

### Issue 3: Generated code won't compile

**Cause:** Missing includes or syntax errors

**Solution:**
- Ensure all includes are present
- Check for missing semicolons
- Verify namespace usage (`std::`)

### Issue 4: Copy to Clipboard not working

**Cause:** No code generated yet

**Solution:**
- First click "Generate C++ Code"
- Then click "Copy to Clipboard"

---

## ?? Tips & Best Practices

### For Code Generation:

1. **Always include comments** when learning
2. **Test generated code** in a compiler
3. **Customize as needed** - it's a starting point
4. **Use as documentation** for your structures

### For Code Parsing:

1. **Keep code simple** - follow patterns
2. **One structure per paste** - don't mix types
3. **Check parse results** before using
4. **Rename structures** for clarity

### General:

1. **Iterate**: Generate ? Modify ? Parse ? Visualize
2. **Learn**: Compare generated code with manual code
3. **Experiment**: Try different patterns
4. **Share**: Export structures as code to collaborate

---

## ?? Supported vs Unsupported

### ? Supported

- **Array**: Basic integer arrays/vectors
- **Linked List**: Singly-linked lists with integers
- **Binary Tree**: Binary search trees
- **Graph**: Undirected and directed graphs

### ? Not Yet Supported

- **Doubly-linked lists**: Only singly-linked
- **N-ary trees**: Only binary trees
- **Weighted graphs**: Weights not extracted
- **Custom data types**: Only integers
- **Complex C++ features**: Templates, inheritance, etc.

### ?? Future Enhancements

- Support for more data types (strings, doubles)
- Weighted graph parsing
- Doubly-linked list support
- AVL/Red-Black tree generation
- Code syntax highlighting
- Live preview during parsing

---

## ?? Quick Start Summary

**Generate Code:**
1. Tools ? Code Generator & Parser
2. Select structure from dropdown
3. Click "Generate C++ Code"
4. Click "Copy to Clipboard"
5. Paste in your IDE

**Parse Code:**
1. Tools ? Code Generator & Parser
2. Switch to "Parse" tab
3. Paste your C++ code
4. Click "Parse & Create Structure"
5. Structure auto-created and visualized

---

## ?? Example Workflows

### Workflow 1: Learn by Generating

```
Visual Structure ? Generate Code ? Study ? Compile ? Understand
```

1. Create a binary tree visually
2. Generate C++ code
3. Study the insert logic
4. Compile and run
5. Compare with visualization

### Workflow 2: Debug by Parsing

```
Buggy Code ? Parse ? Visualize ? Identify Issue ? Fix ? Re-parse
```

1. Have buggy tree code
2. Parse it
3. See visual representation
4. Spot wrong connections
5. Fix code
6. Parse again to verify

### Workflow 3: Rapid Prototyping

```
Idea ? Code Sketch ? Parse ? Visualize ? Refine ? Generate Final
```

1. Sketch graph structure in code
2. Parse to visualize
3. Adjust visually with tools
4. Generate final clean code
5. Use in production

---

## ?? Integration with Other Features

### Works With:

- **Structure Selector**: Parsed structures appear in list
- **Interactive Drawing**: Generate code from drawn structures
- **Algorithm Visualization**: Run algorithms on parsed structures
- **Toolbox**: Tools adapt to parsed structure type
- **Metrics Panel**: Shows stats for parsed structures

### Complements:

- **Multi-Structure Architecture**: Create many structures from code
- **Interactive Mode**: Parse, then modify visually
- **Algorithm Testing**: Parse test cases quickly

---

## ?? Success Stories

**"I used the parser to visualize a complex graph from my homework. Found the bug in 2 minutes!"**
- Student, Data Structures Course

**"Generated code saved me hours. Perfect starting point for my project."**
- Developer, Algorithm Implementation

**"Great for teaching. Students can see their code come to life."**
- Professor, Computer Science

---

**End of Code Generator & Parser Guide**

For more features, see:
- `MULTI_STRUCTURE_GUIDE.md` - Multi-structure architecture
- `UI_IMPROVEMENTS.md` - UI enhancements
- `README.md` - General documentation
