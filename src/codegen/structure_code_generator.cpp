#include "structure_code_generator.h"
#include "../core/list_node.h"
#include "../core/tree_node.h"
#include "../core/graph.h"
#include <sstream>
#include <functional>  // NEW: Add for std::function

std::string StructureCodeGenerator::generateCode(const DataStructure* structure, bool includeComments) {
    if (!structure) {
   return "// Error: Null structure\n";
    }
    
    // Try to cast to each concrete type
    if (const ArrayStructure* arr = dynamic_cast<const ArrayStructure*>(structure)) {
     return generateArrayCode(arr, includeComments);
    }
    else if (const ListStructure* list = dynamic_cast<const ListStructure*>(structure)) {
        return generateListCode(list, includeComments);
    }
    else if (const TreeStructure* tree = dynamic_cast<const TreeStructure*>(structure)) {
        return generateTreeCode(tree, includeComments);
    }
 else if (const GraphStructure* graph = dynamic_cast<const GraphStructure*>(structure)) {
     return generateGraphCode(graph, includeComments);
  }
    
    return "// Error: Unknown structure type\n";
}

std::string StructureCodeGenerator::generateHeader(const std::string& structureType, bool includeComments) {
    std::ostringstream oss;
 
    if (includeComments) {
        oss << "// Auto-generated " << structureType << " C++ Code\n";
        oss << "// Generated by DataViz UIT\n\n";
    }
    
    oss << "#include <iostream>\n";
    oss << "#include <vector>\n";
    if (structureType == "Graph") {
        oss << "#include <map>\n";
      oss << "#include <string>\n";
    }
    oss << "\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateFooter() {
    return "";
}

std::string StructureCodeGenerator::generateArrayCode(const ArrayStructure* arr, bool includeComments) {
    std::ostringstream oss;
 
    oss << generateHeader("Array", includeComments);
    
    if (includeComments) {
        oss << "// Array Structure\n";
    }
    
    oss << "int main() {\n";
 oss << "  // Initialize array\n";
    oss << "    std::vector<int> arr = {";
    
 const auto& data = arr->getData();
    for (size_t i = 0; i < data.size(); ++i) {
        if (i > 0) oss << ", ";
        oss << data[i];
    }
 oss << "};\n\n";
    
    if (includeComments) {
        oss << "    // Display array\n";
    }
oss << "    std::cout << \"Array: \";\n";
    oss << "    for (int val : arr) {\n";
    oss << "        std::cout << val << \" \";\n";
    oss << "    }\n";
    oss << "    std::cout << std::endl;\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateListCode(const ListStructure* list, bool includeComments) {
    std::ostringstream oss;
    
    oss << generateHeader("LinkedList", includeComments);
    
    // Node structure
    if (includeComments) {
     oss << "// Node structure for linked list\n";
    }
    oss << "struct Node {\n";
    oss << "    int value;\n";
    oss << "    Node* next;\n";
    oss << "    Node(int val) : value(val), next(nullptr) {}\n";
    oss << "};\n\n";
  
    // Helper function
    if (includeComments) {
        oss << "// Function to print the list\n";
    }
    oss << "void printList(Node* head) {\n";
    oss << "    Node* current = head;\n";
    oss << "    while (current != nullptr) {\n";
    oss << "        std::cout << current->value;\n";
    oss << "        if (current->next != nullptr) std::cout << \" -> \";\n";
    oss << "        current = current->next;\n";
    oss << "    }\n";
    oss << "    std::cout << \" -> nullptr\" << std::endl;\n";
    oss << "}\n\n";
    
    // Main function
    oss << "int main() {\n";
    
    if (includeComments) {
   oss << "    // Create linked list\n";
    }
    
    // Collect values from the list
  std::vector<int> values;
    const ListNode* current = list->getHead();
    while (current != nullptr) {
        values.push_back(current->value);
  current = current->next;
    }
    
    if (values.empty()) {
        oss << "    Node* head = nullptr;\n";
    } else {
        oss << "    Node* head = new Node(" << values[0] << ");\n";
  if (values.size() > 1) {
            oss << "    Node* current = head;\n\n";
     for (size_t i = 1; i < values.size(); ++i) {
    oss << "    current->next = new Node(" << values[i] << ");\n";
   oss << "    current = current->next;\n";
            }
  }
    }
    
    oss << "\n";
    if (includeComments) {
   oss << "    // Display list\n";
    }
    oss << "    std::cout << \"Linked List: \";\n";
    oss << "    printList(head);\n\n";
    
    if (includeComments) {
        oss << "    // Clean up memory\n";
    }
  oss << "    while (head != nullptr) {\n";
    oss << "        Node* temp = head;\n";
    oss << "        head = head->next;\n";
    oss << "        delete temp;\n";
    oss << "    }\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateTreeCode(const TreeStructure* tree, bool includeComments) {
    std::ostringstream oss;
    
    oss << generateHeader("BinaryTree", includeComments);
    
    // Node structure
    if (includeComments) {
        oss << "// Node structure for binary tree\n";
    }
    oss << "struct TreeNode {\n";
    oss << "    int value;\n";
    oss << "    TreeNode* left;\n";
    oss << " TreeNode* right;\n";
    oss << "    TreeNode(int val) : value(val), left(nullptr), right(nullptr) {}\n";
    oss << "};\n\n";
    
    // Helper functions
    if (includeComments) {
   oss << "// Insert into BST\n";
    }
  oss << "TreeNode* insert(TreeNode* root, int value) {\n";
    oss << "    if (root == nullptr) {\n";
    oss << " return new TreeNode(value);\n";
    oss << "    }\n";
    oss << "    if (value < root->value) {\n";
    oss << "        root->left = insert(root->left, value);\n";
    oss << "    } else {\n";
    oss << "    root->right = insert(root->right, value);\n";
    oss << "    }\n";
    oss << "    return root;\n";
    oss << "}\n\n";
    
    if (includeComments) {
        oss << "// In-order traversal (left, root, right)\n";
    }
    oss << "void inorderTraversal(TreeNode* root) {\n";
    oss << "    if (root == nullptr) return;\n";
    oss << "    inorderTraversal(root->left);\n";
    oss << "    std::cout << root->value << \" \";\n";
    oss << " inorderTraversal(root->right);\n";
    oss << "}\n\n";
    
 // Main function
    oss << "int main() {\n";
    
    if (includeComments) {
  oss << "    // Create binary search tree\n";
    }
    oss << " TreeNode* root = nullptr;\n\n";
    
 // Collect values using in-order traversal
    std::vector<int> values;
    std::function<void(const TreeNode*)> collectValues = [&](const TreeNode* node) {
      if (node == nullptr) return;
        collectValues(node->left);
        values.push_back(node->value);
collectValues(node->right);
    };
    collectValues(tree->getRoot());
    
    if (includeComments) {
  oss << "    // Insert nodes\n";
    }
  for (int value : values) {
        oss << "    root = insert(root, " << value << ");\n";
    }
    
    oss << "\n";
    if (includeComments) {
   oss << "    // Display tree (in-order)\n";
    }
    oss << "    std::cout << \"Binary Tree (in-order): \";\n";
    oss << "    inorderTraversal(root);\n";
    oss << "    std::cout << std::endl;\n\n";
  
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateGraphCode(const GraphStructure* graph, bool includeComments) {
    std::ostringstream oss;
 
    oss << generateHeader("Graph", includeComments);
    
    // Graph class
    if (includeComments) {
   oss << "// Simple Graph implementation using adjacency list\n";
    }
  oss << "class Graph {\n";
    oss << "private:\n";
    oss << "    std::map<std::string, std::vector<std::string>> adjList;\n";
    oss << "    bool directed;\n\n";
    
    oss << "public:\n";
    oss << "    Graph(bool isDirected = false) : directed(isDirected) {}\n\n";
    
    oss << "    void addNode(const std::string& node) {\n";
    oss << "        if (adjList.find(node) == adjList.end()) {\n";
    oss << "    adjList[node] = std::vector<std::string>();\n";
  oss << "      }\n";
    oss << "    }\n\n";
    
oss << "    void addEdge(const std::string& from, const std::string& to) {\n";
    oss << "        addNode(from);\n";
    oss << "        addNode(to);\n";
    oss << "        adjList[from].push_back(to);\n";
    oss << "        if (!directed) {\n";
oss << "   adjList[to].push_back(from);\n";
    oss << "  }\n";
  oss << "    }\n\n";
    
    oss << "    void display() {\n";
    oss << "      for (const auto& pair : adjList) {\n";
    oss << "     std::cout << pair.first << \" -> \";\n";
    oss << "            for (const auto& neighbor : pair.second) {\n";
    oss << "                std::cout << neighbor << \" \";\n";
    oss << "            }\n";
    oss << "            std::cout << std::endl;\n";
    oss << "    }\n";
    oss << "    }\n";
    oss << "};\n\n";
    
    // Main function
    oss << "int main() {\n";
    
    bool isDirected = false;
    if (const Graph* g = graph->getGraph()) {
        isDirected = g->isDirected();
    }
    
    if (includeComments) {
        oss << "    // Create " << (isDirected ? "directed" : "undirected") << " graph\n";
    }
  oss << "    Graph g(" << (isDirected ? "true" : "false") << ");\n\n";
    
    if (includeComments) {
        oss << "    // Add nodes\n";
    }
    
    auto nodes = graph->getNodes();
  for (const auto& node : nodes) {
    oss << "    g.addNode(\"" << node.id << "\");\n";
    }
    
    oss << "\n";
    if (includeComments) {
        oss << "    // Add edges\n";
    }
    
    auto edges = graph->getEdges();
    for (const auto& edge : edges) {
        oss << "    g.addEdge(\"" << edge.from << "\", \"" << edge.to << "\");\n";
    }
    
    oss << "\n";
    if (includeComments) {
   oss << "    // Display graph\n";
    }
    oss << "    std::cout << \"Graph Structure:\\n\";\n";
    oss << "    g.display();\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}
