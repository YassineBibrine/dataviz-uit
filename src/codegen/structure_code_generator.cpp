#include "structure_code_generator.h"
#include "../core/list_node.h"
#include "../core/tree_node.h"
#include "../core/graph.h"
#include <sstream>
#include <functional>
#include <queue>
#include <map>
#include <vector>

std::string StructureCodeGenerator::generateCode(const DataStructure* structure, bool includeComments) {
    if (!structure) {
   return "// Error: Null structure\n";
    }
    
    // Try to cast to each concrete type
    if (const ArrayStructure* arr = dynamic_cast<const ArrayStructure*>(structure)) {
     return generateArrayCode(arr, includeComments);
    }
    else if (const ListStructure* list = dynamic_cast<const ListStructure*>(structure)) {
        return generateListCode(list, includeComments);
    }
    else if (const TreeStructure* tree = dynamic_cast<const TreeStructure*>(structure)) {
        return generateTreeCode(tree, includeComments);
    }
 else if (const GraphStructure* graph = dynamic_cast<const GraphStructure*>(structure)) {
     return generateGraphCode(graph, includeComments);
  }
    
    return "// Error: Unknown structure type\n";
}

std::string StructureCodeGenerator::generateHeader(const std::string& structureType, bool includeComments) {
    std::ostringstream oss;
 
    if (includeComments) {
        oss << "// Auto-generated " << structureType << " C++ Code\n";
        oss << "// Generated by DataViz UIT\n\n";
    }
    
    oss << "#include <iostream>\n";
    oss << "#include <vector>\n";
    if (structureType == "Graph") {
        oss << "#include <map>\n";
      oss << "#include <string>\n";
    }
    oss << "\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateFooter() {
    return "";
}

std::string StructureCodeGenerator::generateArrayCode(const ArrayStructure* arr, bool includeComments) {
    std::ostringstream oss;
 
    oss << generateHeader("Array", includeComments);
    
    if (includeComments) {
        oss << "// Array Structure\n";
    }
    
    oss << "int main() {\n";
 oss << "  // Initialize array\n";
    oss << "    std::vector<int> arr = {";

 const auto& data = arr->getData();
    for (size_t i = 0; i < data.size(); ++i) {
        if (i > 0) oss << ", ";
        oss << data[i];
    }
 oss << "};\n\n";
    
    if (includeComments) {
        oss << "    // Display array\n";
    }
oss << "    std::cout << \"Array: \";\n";
    oss << "    for (int val : arr) {\n";
    oss << "        std::cout << val << \" \";\n";
    oss << "    }\n";
    oss << "    std::cout << std::endl;\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateListCode(const ListStructure* list, bool includeComments) {
    std::ostringstream oss;
    
    oss << generateHeader("LinkedList", includeComments);
    
    // Node structure
    if (includeComments) {
     oss << "// Node structure for linked list\n";
    }
    oss << "struct Node {\n";
    oss << "    int value;\n";
    oss << "    Node* next;\n";
    oss << "    Node(int val) : value(val), next(nullptr) {}\n";
    oss << "};\n\n";
  
    // Helper function
    if (includeComments) {
        oss << "// Function to print the list\n";
    }
    oss << "void printList(Node* head) {\n";
    oss << "    Node* current = head;\n";
    oss << "    while (current != nullptr) {\n";
    oss << "        std::cout << current->value;\n";
    oss << "        if (current->next != nullptr) std::cout << \" -> \";\n";
    oss << "        current = current->next;\n";
    oss << "    }\n";
    oss << "    std::cout << \" -> nullptr\" << std::endl;\n";
    oss << "}\n\n";
    
    // Main function
    oss << "int main() {\n";
    
    if (includeComments) {
   oss << "    // Create linked list\n";
    }
    
    // Collect values from the list
  std::vector<int> values;
    const ListNode* current = list->getHead();
    while (current != nullptr) {
        values.push_back(current->value);
  current = current->next;
    }
    
    if (values.empty()) {
        oss << "    Node* head = nullptr;\n";
    } else {
        oss << "    Node* head = new Node(" << values[0] << ");\n";
  if (values.size() > 1) {
            oss << "    Node* current = head;\n\n";
     for (size_t i = 1; i < values.size(); ++i) {
    oss << "    current->next = new Node(" << values[i] << ");\n";
   oss << "    current = current->next;\n";
            }
  }
    }
    
    oss << "\n";
    if (includeComments) {
   oss << "    // Display list\n";
    }
    oss << "    std::cout << \"Linked List: \";\n";
    oss << "    printList(head);\n\n";
    
    if (includeComments) {
        oss << "    // Clean up memory\n";
    }
  oss << "    while (head != nullptr) {\n";
    oss << "        Node* temp = head;\n";
    oss << "        head = head->next;\n";
    oss << "        delete temp;\n";
    oss << "    }\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateTreeCode(const TreeStructure* tree, bool includeComments) {
    std::ostringstream oss;
    
    oss << generateHeader("BinaryTree", includeComments);
    
    // Node structure
    if (includeComments) {
     oss << "// Node structure for binary tree (manual construction)\n";
    }
    oss << "struct TreeNode {\n";
    oss << "    int value;\n";
    oss << "    TreeNode* left;\n";
  oss << "    TreeNode* right;\n";
  oss << "    TreeNode(int val) : value(val), left(nullptr), right(nullptr) {}\n";
    oss << "};\n\n";
    
    // Helper function for traversal
    if (includeComments) {
        oss << "// Pre-order traversal (root, left, right)\n";
    }
    oss << "void preorderTraversal(TreeNode* root) {\n";
    oss << "    if (root == nullptr) return;\n";
    oss << "    std::cout << root->value << \" \";\n";
    oss << "    preorderTraversal(root->left);\n";
    oss << "    preorderTraversal(root->right);\n";
    oss << "}\n\n";
    
    if (includeComments) {
 oss << "// In-order traversal (left, root, right)\n";
    }
    oss << "void inorderTraversal(TreeNode* root) {\n";
    oss << " if (root == nullptr) return;\n";
    oss << "    inorderTraversal(root->left);\n";
  oss << " std::cout << root->value << \" \";\n";
    oss << "    inorderTraversal(root->right);\n";
    oss << "}\n\n";
    
    // Main function
    oss << "int main() {\n";
 
    if (includeComments) {
oss << "    // Manually construct binary tree structure\n";
    }
 
    // Build map of tree nodes for manual construction
    const TreeNode* root = tree->getRoot();
    
    if (!root) {
        oss << "    TreeNode* root = nullptr;\n";
        oss << "std::cout << \"Empty tree\" << std::endl;\n";
    } else {
        // Collect all nodes using BFS
   std::map<const TreeNode*, int> nodeToIndex;
      std::vector<const TreeNode*> nodeList;
        std::queue<const TreeNode*> bfsQueue;
        
   bfsQueue.push(root);
        int index = 0;
  
     while (!bfsQueue.empty()) {
     const TreeNode* current = bfsQueue.front();
bfsQueue.pop();
    
            if (current) {
         nodeToIndex[current] = index++;
    nodeList.push_back(current);
       
 if (current->left) bfsQueue.push(current->left);
     if (current->right) bfsQueue.push(current->right);
  }
        }
        
    // Generate node creation code
  if (includeComments) {
      oss << "    // Create all nodes\n";
        }
        
    for (size_t i = 0; i < nodeList.size(); ++i) {
    oss << "    TreeNode* node" << i << " = new TreeNode(" << nodeList[i]->value << ");\n";
        }
        
        oss << "\n";
     
        // Generate edge connections
        if (includeComments) {
            oss << "    // Connect nodes (parent-child relationships)\n";
        }
        
    for (size_t i = 0; i < nodeList.size(); ++i) {
    const TreeNode* current = nodeList[i];
       
    if (current->left) {
            int leftIdx = nodeToIndex[current->left];
   oss << "    node" << i << "->left = node" << leftIdx << ";\n";
          }
            
         if (current->right) {
                int rightIdx = nodeToIndex[current->right];
  oss << "    node" << i << "->right = node" << rightIdx << ";\n";
     }
    }
 
        oss << "\n";
        
      if (includeComments) {
  oss << "    // Set root\n";
        }
        oss << "    TreeNode* root = node0;\n";
    }
    
    oss << "\n";
    
    if (includeComments) {
        oss << "    // Display tree structure\n";
    }
oss << "    std::cout << \"Binary Tree (pre-order): \";\n";
    oss << "    preorderTraversal(root);\n";
oss << "    std::cout << std::endl;\n\n";

    oss << "    std::cout << \"Binary Tree (in-order): \";\n";
    oss << "    inorderTraversal(root);\n";
    oss << "    std::cout << std::endl;\n\n";
    
    if (includeComments) {
        oss << "    // Clean up memory (simplified - would need proper traversal in production)\n";
    }
    oss << " // Note: Proper cleanup would require post-order traversal\n";
    oss << "// For demonstration purposes, cleanup is omitted\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}

std::string StructureCodeGenerator::generateGraphCode(const GraphStructure* graph, bool includeComments) {
    std::ostringstream oss;
 
    oss << generateHeader("Graph", includeComments);
    
    // Graph class
    if (includeComments) {
        oss << "// Simple Graph implementation using adjacency list\n";
    }
    oss << "class Graph {\n";
    oss << "private:\n";
    oss << "    std::map<std::string, std::vector<std::string>> adjList;\n";
    oss << "    std::map<std::string, int> nodeValues;\n";
    oss << "    bool directed;\n\n";
    
    oss << "public:\n";
    oss << "    Graph(bool isDirected = false) : directed(isDirected) {}\n\n";
    
    oss << "    void addNode(const std::string& node, int value = 0) {\n";
    oss << "        if (adjList.find(node) == adjList.end()) {\n";
    oss << "adjList[node] = std::vector<std::string>();\n";
    oss << "    nodeValues[node] = value;\n";
    oss << "   }\n";
    oss << "    }\n\n";
    
    oss << "    void addEdge(const std::string& from, const std::string& to) {\n";
    oss << "        addNode(from);\n";
    oss << "   addNode(to);\n";
    oss << "        adjList[from].push_back(to);\n";
    oss << "        if (!directed) {\n";
    oss << "     adjList[to].push_back(from);\n";
    oss << "        }\n";
    oss << "    }\n\n";
    
    oss << "    void display() {\n";
    oss << "        for (const auto& pair : adjList) {\n";
    oss << "   std::cout << pair.first << \" (value: \" << nodeValues[pair.first] << \") -> \";\n";
    oss << " for (const auto& neighbor : pair.second) {\n";
    oss << "      std::cout << neighbor << \" \";\n";
    oss << "        }\n";
    oss << " std::cout << std::endl;\n";
    oss << "        }\n";
    oss << "    }\n";
    oss << "};\n\n";
    
    // Main function
    oss << "int main() {\n";
    
    bool isDirected = false;
    if (const Graph* g = graph->getGraph()) {
        isDirected = g->isDirected();
    }
    
    if (includeComments) {
        oss << "    // Create " << (isDirected ? "directed" : "undirected") << " graph\n";
    }
    oss << "    Graph g(" << (isDirected ? "true" : "false") << ");\n\n";
    
    if (includeComments) {
        oss << "    // Add nodes with values\n";
    }
    
    // Add nodes with their actual values from properties
    if (const Graph* g = graph->getGraph()) {
     auto nodeIds = g->getAllNodeIds();
        for (const auto& nodeId : nodeIds) {
        const Graph::Node* node = g->getNode(nodeId);
      int nodeValue = 0;
            if (node) {
      auto it = node->properties.find("value");
       if (it != node->properties.end()) {
              try {
        nodeValue = std::stoi(it->second);
      } catch (...) {
   nodeValue = 0;
  }
      }
            }
   oss << "  g.addNode(\"" << nodeId << "\", " << nodeValue << ");\n";
        }
    }
    
    oss << "\n";
 if (includeComments) {
        oss << "  // Add edges (fully connected graph)\n";
    }
  
    auto edges = graph->getEdges();
    for (const auto& edge : edges) {
        oss << "    g.addEdge(\"" << edge.from << "\", \"" << edge.to << "\");\n";
    }

    oss << "\n";
    if (includeComments) {
      oss << "    // Display graph\n";
    }
    oss << "    std::cout << \"Graph Structure:\\n\";\n";
    oss << "    g.display();\n\n";
    
    oss << "    return 0;\n";
    oss << "}\n";
    
    return oss.str();
}
